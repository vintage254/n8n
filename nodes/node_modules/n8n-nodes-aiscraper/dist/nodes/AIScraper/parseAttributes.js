"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseAttributesFromJson = exports.parseAttributesFromFields = void 0;
const n8n_workflow_1 = require("n8n-workflow");
function parseAttributesFromFields(context, attributesFieldsParam) {
    var _a;
    const node = context.getNode();
    const currentItemIndex = context.getItemIndex();
    const transformedAttributes = {};
    const fieldValues = (_a = attributesFieldsParam === null || attributesFieldsParam === void 0 ? void 0 : attributesFieldsParam.fieldValues) !== null && _a !== void 0 ? _a : [];
    if (fieldValues.length === 0 && !attributesFieldsParam) {
        return {};
    }
    for (const [index, item] of fieldValues.entries()) {
        if (!item ||
            typeof item.fieldName !== 'string' ||
            typeof item.fieldType !== 'string' ||
            (item.fieldDescription !== undefined && typeof item.fieldDescription !== 'string')) {
            throw new n8n_workflow_1.NodeOperationError(node, `Attribute at index ${index} is malformed or missing required properties (fieldName, fieldType). fieldDescription is optional.`, { itemIndex: currentItemIndex });
        }
        const fieldName = item.fieldName.trim();
        const fieldDescription = (item.fieldDescription || '').trim();
        if (!fieldName) {
            throw new n8n_workflow_1.NodeOperationError(node, `Empty Field Name at index ${index}.`, { itemIndex: currentItemIndex });
        }
        if (!item.fieldType) {
            throw new n8n_workflow_1.NodeOperationError(node, `Attribute Type for "${fieldName}" (at index ${index}) cannot be empty.`, { itemIndex: currentItemIndex });
        }
        transformedAttributes[fieldName] = { description: fieldDescription, type: item.fieldType };
    }
    return transformedAttributes;
}
exports.parseAttributesFromFields = parseAttributesFromFields;
function parseAttributesFromJson(context, attributesJsonInput) {
    var _a;
    const node = context.getNode();
    const currentItemIndex = context.getItemIndex();
    const transformedAttributes = {};
    let parsedObject;
    if (typeof attributesJsonInput === 'string') {
        const trimmedJsonInput = attributesJsonInput.trim();
        if (trimmedJsonInput === '') {
            return {};
        }
        try {
            parsedObject = JSON.parse(trimmedJsonInput);
        }
        catch (error) {
            throw new n8n_workflow_1.NodeOperationError(node, `Attributes field contains invalid JSON: ${error.message}`, { itemIndex: currentItemIndex });
        }
    }
    else if (typeof attributesJsonInput === 'object' && attributesJsonInput !== null) {
        if (Array.isArray(attributesJsonInput)) {
            throw new n8n_workflow_1.NodeOperationError(node, `Attributes field must be a JSON object, not an array.`, { itemIndex: currentItemIndex });
        }
        parsedObject = attributesJsonInput;
    }
    else if (attributesJsonInput === null || attributesJsonInput === undefined) {
        return {};
    }
    else {
        throw new n8n_workflow_1.NodeOperationError(node, `Attributes field is an unexpected type: ${typeof attributesJsonInput}.`, { itemIndex: currentItemIndex });
    }
    if (typeof parsedObject !== 'object' || parsedObject === null || Array.isArray(parsedObject)) {
        throw new n8n_workflow_1.NodeOperationError(node, `Attributes must resolve to a JSON object. Received: ${Array.isArray(parsedObject) ? 'an array' : typeof parsedObject}.`, { itemIndex: currentItemIndex });
    }
    for (const [key, value] of Object.entries(parsedObject)) {
        const fieldName = key.trim();
        if (!fieldName) {
            throw new n8n_workflow_1.NodeOperationError(node, 'Attribute name (JSON key) cannot be empty.', { itemIndex: currentItemIndex });
        }
        if (typeof value !== 'object' || value === null || Array.isArray(value)) {
            throw new n8n_workflow_1.NodeOperationError(node, `Value for attribute "${fieldName}" in JSON must be an object.`, { itemIndex: currentItemIndex });
        }
        const attributeDetails = value;
        const descriptionFromPayload = attributeDetails.description;
        let description;
        if (descriptionFromPayload !== undefined) {
            if (typeof descriptionFromPayload !== 'string') {
                throw new n8n_workflow_1.NodeOperationError(node, `Attribute "${fieldName}" in JSON has an invalid "description" type. It must be a string. Found: ${typeof descriptionFromPayload}`, { itemIndex: currentItemIndex });
            }
            description = descriptionFromPayload.trim();
        }
        const type = (_a = attributeDetails.type) === null || _a === void 0 ? void 0 : _a.trim();
        if (typeof type !== 'string' || !type) {
            throw new n8n_workflow_1.NodeOperationError(node, `Attribute "${fieldName}" in JSON is missing a valid "type".`, { itemIndex: currentItemIndex });
        }
        transformedAttributes[fieldName] = { description: description !== null && description !== void 0 ? description : '', type };
    }
    return transformedAttributes;
}
exports.parseAttributesFromJson = parseAttributesFromJson;
//# sourceMappingURL=parseAttributes.js.map